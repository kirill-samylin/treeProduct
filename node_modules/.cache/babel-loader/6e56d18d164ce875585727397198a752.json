{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { fetchTree } from \"./AppApi\";\nimport { product } from \"../../module\";\nconst initialState = {\n  products: [],\n  list: [],\n  loading: false\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\nexport const treeAsync = createAsyncThunk(\"tree/fetchTree\", async amount => {\n  const response = await fetchTree(amount); // The value we return becomes the `fulfilled` action payload\n\n  return response.data;\n});\nexport const treeSlice = createSlice({\n  name: \"tree\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    changeStatus: (state, action) => {\n      const product = action.payload;\n      state.products = product.setStatus(product, state.products, !product.active);\n    },\n    changeExpand: (state, action) => {\n      const product = action.payload;\n      state.products = product.set(product, state.products, 'expanded', !product.expanded);\n    },\n    insert: (state, action) => {\n      const product = action.payload;\n      state.products = [product, ...state.products];\n    }\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: builder => {\n    builder.addCase(treeAsync.pending, state => {\n      state.loading = true;\n    }).addCase(treeAsync.fulfilled, (state, action) => {\n      const list = dishes.flatten(action.payload);\n      const products = dishes.tree(action.payload, list);\n      state.loading = false;\n      state.products = products;\n      state.list = list;\n    });\n  }\n});\nexport const {\n  changeStatus,\n  changeExpand\n} = treeSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n\nexport const selectProducts = state => state.tree.products;\nexport default treeSlice.reducer;","map":{"version":3,"sources":["/Users/kirillsamylin/Desktop/table/stop-list/src/components/App/App.slice.js"],"names":["createAsyncThunk","createSlice","fetchTree","product","initialState","products","list","loading","treeAsync","amount","response","data","treeSlice","name","reducers","changeStatus","state","action","payload","setStatus","active","changeExpand","set","expanded","insert","extraReducers","builder","addCase","pending","fulfilled","dishes","flatten","tree","actions","selectProducts","reducer"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AACA,SAASC,SAAT,QAA0B,UAA1B;AACA,SAASC,OAAT,QAAwB,cAAxB;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,QAAQ,EAAE,EADS;AAEnBC,EAAAA,IAAI,EAAE,EAFa;AAGnBC,EAAAA,OAAO,EAAE;AAHU,CAArB,C,CAMA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAGR,gBAAgB,CACvC,gBADuC,EAEvC,MAAOS,MAAP,IAAkB;AAChB,QAAMC,QAAQ,GAAG,MAAMR,SAAS,CAACO,MAAD,CAAhC,CADgB,CAEhB;;AACA,SAAOC,QAAQ,CAACC,IAAhB;AACD,CANsC,CAAlC;AASP,OAAO,MAAMC,SAAS,GAAGX,WAAW,CAAC;AACnCY,EAAAA,IAAI,EAAE,MAD6B;AAEnCT,EAAAA,YAFmC;AAGnC;AACAU,EAAAA,QAAQ,EAAE;AACRC,IAAAA,YAAY,EAAE,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC/B,YAAMd,OAAO,GAAGc,MAAM,CAACC,OAAvB;AACAF,MAAAA,KAAK,CAACX,QAAN,GAAiBF,OAAO,CAACgB,SAAR,CACfhB,OADe,EAEfa,KAAK,CAACX,QAFS,EAGf,CAACF,OAAO,CAACiB,MAHM,CAAjB;AAKD,KARO;AASRC,IAAAA,YAAY,EAAE,CAACL,KAAD,EAAQC,MAAR,KAAmB;AAC/B,YAAMd,OAAO,GAAGc,MAAM,CAACC,OAAvB;AACAF,MAAAA,KAAK,CAACX,QAAN,GAAiBF,OAAO,CAACmB,GAAR,CAAYnB,OAAZ,EAAqBa,KAAK,CAACX,QAA3B,EAAqC,UAArC,EAAiD,CAACF,OAAO,CAACoB,QAA1D,CAAjB;AACD,KAZO;AAaRC,IAAAA,MAAM,EAAE,CAACR,KAAD,EAAQC,MAAR,KAAmB;AACzB,YAAMd,OAAO,GAAGc,MAAM,CAACC,OAAvB;AACAF,MAAAA,KAAK,CAACX,QAAN,GAAiB,CAACF,OAAD,EAAU,GAAGa,KAAK,CAACX,QAAnB,CAAjB;AACD;AAhBO,GAJyB;AAsBnC;AACA;AACAoB,EAAAA,aAAa,EAAGC,OAAD,IAAa;AAC1BA,IAAAA,OAAO,CACJC,OADH,CACWnB,SAAS,CAACoB,OADrB,EAC+BZ,KAAD,IAAW;AACrCA,MAAAA,KAAK,CAACT,OAAN,GAAgB,IAAhB;AACD,KAHH,EAIGoB,OAJH,CAIWnB,SAAS,CAACqB,SAJrB,EAIgC,CAACb,KAAD,EAAQC,MAAR,KAAmB;AAC/C,YAAMX,IAAI,GAAGwB,MAAM,CAACC,OAAP,CAAed,MAAM,CAACC,OAAtB,CAAb;AACA,YAAMb,QAAQ,GAAGyB,MAAM,CAACE,IAAP,CAAYf,MAAM,CAACC,OAAnB,EAA4BZ,IAA5B,CAAjB;AACAU,MAAAA,KAAK,CAACT,OAAN,GAAgB,KAAhB;AACAS,MAAAA,KAAK,CAACX,QAAN,GAAiBA,QAAjB;AACAW,MAAAA,KAAK,CAACV,IAAN,GAAaA,IAAb;AACD,KAVH;AAWD;AApCkC,CAAD,CAA7B;AAuCP,OAAO,MAAM;AAAES,EAAAA,YAAF;AAAgBM,EAAAA;AAAhB,IAAkCT,SAAS,CAACqB,OAAlD,C,CAEP;AACA;AACA;;AACA,OAAO,MAAMC,cAAc,GAAIlB,KAAD,IAAWA,KAAK,CAACgB,IAAN,CAAW3B,QAA7C;AAGP,eAAeO,SAAS,CAACuB,OAAzB","sourcesContent":["import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { fetchTree } from \"./AppApi\";\nimport { product } from \"../../module\";\n\nconst initialState = {\n  products: [],\n  list: [],\n  loading: false,\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const treeAsync = createAsyncThunk(\n  \"tree/fetchTree\",\n  async (amount) => {\n    const response = await fetchTree(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const treeSlice = createSlice({\n  name: \"tree\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    changeStatus: (state, action) => {\n      const product = action.payload;\n      state.products = product.setStatus(\n        product,\n        state.products,\n        !product.active\n      );\n    },\n    changeExpand: (state, action) => {\n      const product = action.payload;\n      state.products = product.set(product, state.products, 'expanded', !product.expanded);\n    },\n    insert: (state, action) => {\n      const product = action.payload;\n      state.products = [product, ...state.products];\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(treeAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(treeAsync.fulfilled, (state, action) => {\n        const list = dishes.flatten(action.payload);\n        const products = dishes.tree(action.payload, list);\n        state.loading = false;\n        state.products = products;\n        state.list = list;\n      });\n  },\n});\n\nexport const { changeStatus, changeExpand, } = treeSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectProducts = (state) => state.tree.products;\n\n\nexport default treeSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}